{# impl_main.rs.txt #}
// Implementation crate main entry point
// This file is generated as a starting point.
// You can modify this file freely - it will NOT be auto-regenerated.

use {{ crate_name }}::registry;
use brrtrouter::dispatcher::Dispatcher;
use brrtrouter::middleware::MetricsMiddleware;
use brrtrouter::router::Router;
use brrtrouter::runtime_config::RuntimeConfig;
use brrtrouter::server::AppService;
use brrtrouter::server::HttpServer;
use clap::Parser;
use std::io;
use std::path::PathBuf;
use std::fs;

// Only use jemalloc if BRRTRouter isn't already providing it
#[cfg(not(feature = "brrtrouter/jemalloc"))]
use tikv_jemallocator::Jemalloc;

#[cfg(not(feature = "brrtrouter/jemalloc"))]
#[global_allocator]
static GLOBAL: Jemalloc = Jemalloc;

#[derive(Parser)]
struct Args {
    #[arg(short, long, default_value = "./doc/openapi.yaml")]
    spec: PathBuf,
    #[arg(long)]
    static_dir: Option<PathBuf>,
    #[arg(long, default_value = "./doc")]
    doc_dir: PathBuf,
    #[arg(long, default_value_t = false)]
    hot_reload: bool,
    #[arg(long)]
    test_api_key: Option<String>,
    #[arg(long, default_value = "./config/config.yaml")]
    config: PathBuf,
}

fn main() -> io::Result<()> {
    // Initialize structured logging
    if let Err(e) = brrtrouter::otel::init_logging_with_config(&brrtrouter::otel::LogConfig::from_env()) {
        eprintln!("[logging][error] failed to init tracing subscriber: {e}");
    }

    let args = Args::parse();
    // Configure coroutine stack size
    let config = RuntimeConfig::from_env();
    may::config().set_stack_size(config.stack_size);
    
    // Load OpenAPI spec
    let spec_path = if args.spec.is_relative() {
        let base = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        base.join(args.spec)
    } else {
        args.spec.clone()
    };
    
    let (routes, schemes, _slug) = brrtrouter::spec::load_spec_full(spec_path.to_str().unwrap())
        .expect("failed to load OpenAPI spec");
    
    let router = std::sync::Arc::new(std::sync::RwLock::new(Router::new(routes.clone())));
    router.read().unwrap().dump_routes();
    
    // Create dispatcher and middleware
    let mut dispatcher = Dispatcher::new();
    let metrics = std::sync::Arc::new(MetricsMiddleware::new());
    dispatcher.add_middleware(metrics.clone());
    
    // Create memory tracking middleware
    let memory = std::sync::Arc::new(brrtrouter::middleware::MemoryMiddleware::new());
    brrtrouter::middleware::memory::start_memory_monitor(memory.clone());
    
    // Register handlers from generated crate
    unsafe {
        registry::register_from_spec(&mut dispatcher, &routes);
    }
    
    let dispatcher = std::sync::Arc::new(std::sync::RwLock::new(dispatcher));
    let mut service = AppService::new(
        router,
        dispatcher,
        schemes,
        spec_path.clone(),
        args.static_dir.clone(),
        Some(args.doc_dir.clone()),
    );
    service.set_metrics_middleware(metrics);
    service.set_memory_middleware(memory);

    // Start the HTTP server
    let handle = HttpServer(service).start("0.0.0.0:8080")?;
    handle.join().map_err(|e| {
        io::Error::other(format!("Server error: {e:?}"))
    })?;
    
    Ok(())
}

