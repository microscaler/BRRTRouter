name: Test BRRTRouter

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    env:
      BRRTR_LOCAL: "1"
      RUST_BACKTRACE: "1"
      RUST_LOG: "debug"

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Cache cargo registry
        if: ${{ !env.ACT }}
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          key: ${{ runner.os }}-cargo-v2-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-v2-

      - name: Install Just
        uses: extractions/setup-just@v3

      - name: Cargo build
        #run: cargo build --all --all-features # this will also build the example projects, which are currently broken
        run: cargo build

      - name: Generate handlers
        run: cargo run --bin brrtrouter-gen -- generate --spec examples/openapi.yaml --force

      - name: Cargo build again with handlers
        #run: cargo build --all --all-features # this will also build the example projects, which are currently broken
        run: cargo build

      - name: Build generator (release)
        run: cargo build --release --bin brrtrouter-gen

      - name: Upload generator artifact
        if: ${{ !env.ACT }}
        uses: actions/upload-artifact@v4
        with:
          name: brrtrouter-gen-linux
          path: target/release/brrtrouter-gen
          retention-days: 1

      - name: Install musl target for pet_store
        run: rustup target add x86_64-unknown-linux-musl

      - name: Install musl tools (provides musl-gcc for ring)
        run: sudo apt-get update || apt-get update && (sudo apt-get install -y musl-tools || apt-get install -y musl-tools)

      - name: Build pet_store (musl, release)
        env:
          CC_x86_64_unknown_linux_musl: musl-gcc
          CARGO_TARGET_X86_64_UNKNOWN_LINUX_MUSL_LINKER: musl-gcc
        run: cargo build --release -p pet_store --target x86_64-unknown-linux-musl

      - name: Upload pet_store binary artifact
        if: ${{ !env.ACT }}
        uses: actions/upload-artifact@v4
        with:
          name: pet_store-musl
          path: target/x86_64-unknown-linux-musl/release/pet_store
          retention-days: 1

      - name: Lint with Clippy
        # run: cargo clippy --all-targets --all-features -- -D warnings || true - runs clippy on all targets and features, but fails the build on warnings
        run: cargo clippy -- -D warnings || true

      - name: Run tests (reqwest-based)
        run: cargo test -- --nocapture

      - name: Install cargo-llvm-cov
        if: ${{ !env.ACT }}
        run: cargo install cargo-llvm-cov

      - name: Measure coverage
        if: ${{ !env.ACT }}
        run: cargo llvm-cov  #--no-report

  e2e-docker:
    needs: build-and-test
    runs-on: ubuntu-latest
    env:
      RUST_BACKTRACE: "1"
      RUST_LOG: "debug"
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Build generator (ACT local)
        if: ${{ env.ACT }}
        run: cargo build --release --bin brrtrouter-gen

      - name: Download generator artifact
        if: ${{ !env.ACT }}
        uses: actions/download-artifact@v4
        with:
          name: brrtrouter-gen-linux
          path: ./dist

      - name: Install musl target (ACT local)
        if: ${{ env.ACT }}
        run: rustup target add x86_64-unknown-linux-musl

      - name: Install musl tools (ACT local)
        if: ${{ env.ACT }}
        run: sudo apt-get update || apt-get update && (sudo apt-get install -y musl-tools || apt-get install -y musl-tools)

      - name: Build pet_store (musl, release) (ACT local)
        if: ${{ env.ACT }}
        env:
          CC_x86_64_unknown_linux_musl: musl-gcc
          CARGO_TARGET_X86_64_UNKNOWN_LINUX_MUSL_LINKER: musl-gcc
        run: cargo build --release -p pet_store --target x86_64-unknown-linux-musl

      - name: Download pet_store binary artifact
        if: ${{ !env.ACT }}
        uses: actions/download-artifact@v4
        with:
          name: pet_store-musl
          path: ./dist

      - name: Make generator executable
        run: chmod +x ./dist/brrtrouter-gen

      - name: Regenerate pet_store example (artifact)
        run: ./dist/brrtrouter-gen generate --spec examples/openapi.yaml --force

      - name: Regenerate pet_store example (ACT local)
        if: ${{ env.ACT }}
        run: ./target/release/brrtrouter-gen generate --spec examples/openapi.yaml --force

      - name: Build e2e Docker image (freshly generated app + provided binary)
        run: docker build --build-arg PETSTORE_BIN=/build/dist/pet_store --no-cache -t brrtrouter-petstore:e2e .

      - name: Build e2e Docker image (ACT local binary)
        if: ${{ env.ACT }}
        run: docker build --build-arg PETSTORE_BIN=/build/target/x86_64-unknown-linux-musl/release/pet_store --no-cache -t brrtrouter-petstore:e2e .

      - name: Install uuidgen
        run: sudo apt-get update && sudo apt-get install -y uuid-runtime

      - name: Tag and push ttl.sh ephemeral image
        id: ttl
        run: |
          IMAGE_NAME=$(uuidgen)
          IMAGE="ttl.sh/${IMAGE_NAME}:1h"
          echo "Tagging $IMAGE"
          docker tag brrtrouter-petstore:e2e "$IMAGE"
          docker push "$IMAGE"
          echo "image=$IMAGE" >> $GITHUB_OUTPUT

      - name: Prepare JUnit tooling
        run: |
          mkdir -p target/e2e
          cargo install cargo2junit || true

      - name: Run e2e tests (docker integration)
        env:
          E2E_DOCKER: "1"
        run: |
          # Single run: emit JSON, save to file, and convert to JUnit
          cargo test --test docker_integration_tests -- --format=json \
            | tee target/e2e/docker.json \
            | cargo2junit > target/e2e/junit-docker.xml || true

      - name: Run HTTP integration tests
        run: |
          # Single run: emit JSON, save to file, and convert to JUnit
          cargo test --test curl_integration_tests -- --test-threads=1 --format=json \
            | tee target/e2e/curl.json \
            | cargo2junit > target/e2e/junit-curl.xml || true

      - name: Upload JUnit reports
        if: ${{ !env.ACT }}
        uses: actions/upload-artifact@v4
        with:
          name: junit-e2e
          path: target/e2e/*.xml
          retention-days: 1

    outputs:
      image: ${{ steps.ttl.outputs.image }}

  perf-wrk:
    needs: e2e-docker
    runs-on: ubuntu-latest
    services:
      petstore:
        image: ${{ needs.e2e-docker.outputs.image }}
        options: --name petstore
        ports:
          - 8080:8080
        env:
          # Enable jemalloc heap profiling in the service container
          MALLOC_CONF: prof:true,prof_active:true,prof_prefix:/tmp/jeprof,lg_prof_sample:20
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install wrk
        run: sudo apt-get update && sudo apt-get install -y wrk curl

      - name: Install perf and FlameGraph tools
        run: |
          sudo apt-get update
          sudo apt-get install -y linux-tools-common linux-tools-generic linux-tools-$(uname -r) git perl
          git clone https://github.com/brendangregg/FlameGraph.git

      - name: Wait for readiness
        run: |
          for i in $(seq 1 120); do \
            code=$(curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:8080/health || true); \
            [ "$code" = "200" ] && echo "ready" && break; \
            sleep 0.5; \
          done

      - name: Resolve service container PID
        id: svc
        run: |
          CID=$(docker ps --filter "name=^/petstore$" -q)
          echo "Container: $CID"
          PID=$(docker inspect -f '{{.State.Pid}}' "$CID")
          echo "pid=$PID" >> $GITHUB_OUTPUT

      - name: Profile with perf while running wrk
        run: |
          set -e
          # Tune perf permissions
          sudo sysctl kernel.perf_event_paranoid=1 || true
          sudo sysctl kernel.kptr_restrict=0 || true

          # Resolve container PID (named service)
          CID=$(docker ps --filter "name=^/petstore$" -q)
          echo "Container: $CID"
          PID=$(docker inspect -f '{{.State.Pid}}' "$CID")
          echo "Service PID: $PID"

          # Compute load params
          CORES=$(nproc || getconf _NPROCESSORS_ONLN || echo 2)
          THREADS="$CORES"
          CONNS=$((CORES * 50))
          echo "Detected cores: $CORES; threads=$THREADS; connections=$CONNS"

          # Ensure repo script exists
          test -f scripts/post.lua || { echo "scripts/post.lua not found"; exit 1; }

          # Run workload under perf so recording ends cleanly when workload finishes
          sudo perf record -F 99 -g -p "$PID" -- bash -lc "
            set -e
            wrk -t$THREADS -c$CONNS -d60s http://127.0.0.1:8080/health | tee wrk_health.txt
            wrk -t$THREADS -c$CONNS -d60s -H 'X-API-Key: test123' http://127.0.0.1:8080/pets | tee wrk_pets.txt
            wrk -t$THREADS -c$CONNS -d60s -s scripts/post.lua http://127.0.0.1:8080/pets | tee wrk_pets_post.txt
          "

      - name: Build flamegraph
        run: |
          set -e
          # Ensure FlameGraph tools are present
          if [ ! -d FlameGraph ]; then
            git clone https://github.com/brendangregg/FlameGraph.git
          fi
          ls -la FlameGraph | sed -n '1,5p'
          # Generate folded stacks and flamegraph from perf.data produced above
          if [ -f perf.data ]; then
            sudo perf script -i perf.data | ./FlameGraph/stackcollapse-perf.pl > out.folded || true
            if [ -s out.folded ]; then
              ./FlameGraph/flamegraph.pl out.folded > flame.svg || true
            else
              echo "No stacks found in out.folded"
            fi
          else
            echo "perf.data not found"
          fi

      - name: Copy jemalloc profiles from container
        run: |
          CID=$(docker ps --filter "name=^/petstore$" -q)
          mkdir -p jemalloc_profiles
          # Copy /tmp directory and extract jeprof files
          docker cp "$CID":/tmp jemalloc_tmp 2>/dev/null || true
          if ls jemalloc_tmp 1>/dev/null 2>&1; then
            find jemalloc_tmp -maxdepth 1 -type f -name 'jeprof.*' -exec mv {} jemalloc_profiles/ \; || true
          fi

      - name: Upload profiling artifacts
        uses: actions/upload-artifact@v4
        with:
          name: profiling-artifacts
          retention-days: 1
          path: |
            flame.svg
            out.folded
            jemalloc_profiles

      - name: Upload wrk artifacts
        uses: actions/upload-artifact@v4
        with:
          name: wrk-results
          retention-days: 1
          path: |
            wrk_health.txt
            wrk_pets.txt
            wrk_pets_post.txt
